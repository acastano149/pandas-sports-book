# Rendimiento y Optimizaci√≥n

Este cap√≠tulo cubre t√©cnicas para trabajar eficientemente.

```{pyodide}
import pandas as pd
import numpy as np

# ============================================
# DATASET GRANDE PARA OPTIMIZACI√ìN
# ============================================
np.random.seed(42)
n = 5000  # 5000 sesiones simuladas

jugadores = [f'ATL_{i:03d}' for i in range(1, 51)]
posiciones = ['Delantero', 'Mediocentro', 'Defensa', 'Portero', 'Extremo']

gps = pd.DataFrame({
    'JugadorID': np.random.choice(jugadores, n),
    'Posicion': np.random.choice(posiciones, n),
    'TipoSesion': np.random.choice(['Entrenamiento', 'Partido', 'Recuperaci√≥n'], n, p=[0.6, 0.25, 0.15]),
    'Distancia_m': np.random.randint(2000, 15000, n),
    'HSR_m': np.random.randint(50, 1500, n),
    'Sprint_m': np.random.randint(10, 500, n),
    'RPE': np.random.randint(1, 11, n),
    'HR_Media': np.random.randint(120, 180, n),
    'Fecha': pd.date_range('2023-01-01', periods=n, freq='H').strftime('%Y-%m-%d')
})

print(f"‚úÖ Dataset grande: {n:,} filas x {gps.shape[1]} columnas")
print(f"Memoria: {gps.memory_usage(deep=True).sum() / 1024:.1f} KB")
```

***

## 1. Optimizaci√≥n de Tipos

### Ejemplo 1.1: Inspeccionar memoria

```{pyodide}
print("Tipos actuales:")
print(gps.dtypes)
print(f"\nMemoria total: {gps.memory_usage(deep=True).sum() / 1024:.2f} KB")
```

### Ejemplo 1.2: Convertir a category

**¬øCu√°ndo?** Columnas con pocos valores √∫nicos (como 'TipoSesion').

```{pyodide}
gps_opt = gps.copy()
gps_opt['TipoSesion'] = gps_opt['TipoSesion'].astype('category')
gps_opt['JugadorID'] = gps_opt['JugadorID'].astype('category')

print(f"Original: {gps.memory_usage(deep=True).sum() / 1024:.2f} KB")
print(f"Optimizado: {gps_opt.memory_usage(deep=True).sum() / 1024:.2f} KB")
```

---

### üß† Pr√°ctica 1.1

¬øCu√°ntos valores √∫nicos tiene 'TipoSesion'? ¬øEs buena candidata para category?

```{pyodide}
# Pista: df['col'].nunique()

# Escribe tu c√≥digo aqu√≠:


```

::: {.callout-tip collapse="true"}
## Ver soluci√≥n
```python
print(f"Valores √∫nicos: {gps['TipoSesion'].nunique()}")
print("S√≠, es buena candidata porque tiene pocos valores √∫nicos")
```
:::

***

## 2. Operaciones Eficientes

### Ejemplo 2.1: Evitar apply()

**‚ùå LENTO:**
```python
df.apply(lambda row: row['a'] / row['b'], axis=1)
```

**‚úÖ R√ÅPIDO (vectorizado):**
```{pyodide}
# Las operaciones vectorizadas son 10-100x m√°s r√°pidas
gps['Intensidad'] = gps['HSR_m'] / gps['Distancia_m']
gps[['HSR_m', 'Distancia_m', 'Intensidad']].head()
```

### Ejemplo 2.2: query() para filtros

```{pyodide}
# query() es m√°s legible y eficiente para datasets grandes
resultado = gps.query("TipoSesion == 'Partido' and RPE > 7")
print(f"Sesiones filtradas: {len(resultado)}")
```

---

### üß† Pr√°ctica 2.1

Calcula de forma vectorizada: Carga = RPE √ó 10.

```{pyodide}
# Pista: df['Nueva'] = df['col'] * valor

# Escribe tu c√≥digo aqu√≠:


```

::: {.callout-tip collapse="true"}
## Ver soluci√≥n
```python
gps['Carga'] = gps['RPE'] * 10
gps[['RPE', 'Carga']].head()
```
:::

***

## üèÜ Mini-Proyecto: Optimizaci√≥n de un Pipeline de An√°lisis

### Pregunta 1: Ahorro de Memoria con Categories
¬øCu√°nta memoria se ahorra al convertir TODAS las columnas de texto (object) a category?

```{pyodide}
# Pista: memory_usage(deep=True).sum()

# Escribe tu c√≥digo aqu√≠:


```

::: {.callout-tip collapse="true"}
## Ver soluci√≥n
```python
mem_antes = gps.memory_usage(deep=True).sum() / 1024

gps_opt = gps.copy()
for col in gps_opt.select_dtypes(include='object').columns:
    gps_opt[col] = gps_opt[col].astype('category')

mem_despues = gps_opt.memory_usage(deep=True).sum() / 1024

print(f"Antes: {mem_antes:.1f} KB")
print(f"Despu√©s: {mem_despues:.1f} KB")
print(f"Ahorro: {(1 - mem_despues/mem_antes)*100:.1f}%")
```
:::

### Pregunta 2: Filtrado Eficiente con query()
Filtra todas las sesiones de Partido con Distancia > 10000 m, RPE >= 8, y HR_Media > 160.

```{pyodide}
# Pista: .query("cond1 and cond2 and cond3")

# Escribe tu c√≥digo aqu√≠:


```

::: {.callout-tip collapse="true"}
## Ver soluci√≥n
```python
resultado = gps.query("TipoSesion == 'Partido' and Distancia_m > 10000 and RPE >= 8 and HR_Media > 160")
print(f"Sesiones de alta intensidad: {len(resultado)}")
resultado.head()
```
:::

### Pregunta 3: C√°lculo Vectorizado de Intensidad
Calcula de forma vectorizada: Intensidad = HSR_m / Distancia_m √ó 100. Evita usar apply().

```{pyodide}
# Pista: Operaciones directas entre columnas

# Escribe tu c√≥digo aqu√≠:


```

::: {.callout-tip collapse="true"}
## Ver soluci√≥n
```python
# Vectorizado (r√°pido)
gps['Intensidad_Pct'] = (gps['HSR_m'] / gps['Distancia_m']) * 100

# Ver resultado
gps[['JugadorID', 'HSR_m', 'Distancia_m', 'Intensidad_Pct']].head()
```
:::

### Pregunta 4: Top Jugadores con Pipeline Eficiente
Encuentra los 5 jugadores con mayor distancia total en Partidos. Usa un pipeline completo.

```{pyodide}
# Pista: query + groupby + sum + nlargest

# Escribe tu c√≥digo aqu√≠:


```

::: {.callout-tip collapse="true"}
## Ver soluci√≥n
```python
(
    gps
    .query("TipoSesion == 'Partido'")
    .groupby('JugadorID')['Distancia_m']
    .sum()
    .nlargest(5)
)
```
:::

---

## Resumen

| Problema | Soluci√≥n |
|----------|----------|
| Columnas de texto repetitivas | `.astype('category')` |
| Filtros complejos lentos | `.query()` |
| apply() lento | Operaciones vectorizadas |
| Cargar CSV grande | `usecols=`, `dtype=`, `nrows=` |

---

**¬°Felicidades!** üéâ Has completado la Parte 3. Contin√∫a con la **Parte 4: An√°lisis Avanzado** para aprender visualizaci√≥n de f√∫tbol, estad√≠sticas aplicadas y uso de APIs profesionales.
